{"version":3,"file":"swiss.umd.js","sources":["../src/swiss.ts"],"sourcesContent":[";(function () {\n  /*\n  |--------------------------------------------------------------------------\n  | Types\n  |--------------------------------------------------------------------------\n  */\n\n  type TBaseClassOrAttrActionType = \"toggle\" | \"add\" | \"remove\"\n\n  type TActionOptions = {\n    delay?: number\n    debounce?: number\n    [key: string]: unknown\n  }\n\n  type TAttrMap = {\n    [key: string]: string | null\n  }\n\n  type TRunAction = {\n    type: \"run\"\n    js: string\n    options?: TActionOptions\n  }\n\n  type TEventAction = {\n    type: \"event\"\n    eventNames: string[] // supports event(foo bar baz)\n    options?: TActionOptions\n  }\n\n  type TParsedAction =\n    | TClassAction\n    | TAttrAction\n    | TComboAction\n    | TRunAction\n    | TEventAction\n\n  type TInitialClassState = {\n    el: Element\n    className: string\n    hasClass: boolean\n  }\n\n  type TInitialAttrState = {\n    el: Element\n    attr: string\n    value: string | null\n  }\n\n  type TInitialState = (TInitialClassState | TInitialAttrState)[]\n\n  interface TBaseClassOrAttrAction {\n    type: TBaseClassOrAttrActionType\n    selector: string\n    options?: TActionOptions\n  }\n\n  interface TClassAction extends TBaseClassOrAttrAction {\n    classNames: string[]\n    attrs?: undefined\n  }\n\n  interface TAttrAction extends TBaseClassOrAttrAction {\n    attrs: TAttrMap\n    classNames?: undefined\n  }\n\n  interface TComboAction extends TBaseClassOrAttrAction {\n    classNames: string[]\n    attrs: TAttrMap\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Constants\n  |--------------------------------------------------------------------------\n  */\n\n  const DEFAULT_DEBOUNCE_MS = 100\n  const DEFAULT_INTERSECTION_THRESHOLD = 0\n\n  /*\n  |--------------------------------------------------------------------------\n  | Utils\n  |--------------------------------------------------------------------------\n  */\n\n  function isClassOrAttrActionType(\n    actionType: string,\n  ): actionType is TBaseClassOrAttrActionType {\n    return [\"toggle\", \"add\", \"remove\"].includes(actionType)\n  }\n\n  function hasClassNames(\n    action: TParsedAction,\n  ): action is TClassAction | TComboAction {\n    return \"classNames\" in action\n  }\n\n  function hasAttrs(\n    action: TParsedAction,\n  ): action is TAttrAction | TComboAction {\n    return \"attrs\" in action\n  }\n\n  /**\n   * Expand event shorthands (e.g., \"hover\" -> \"mouseenter mouseleave\")\n   */\n  function expandEventShorthands(events: string[]): string[] {\n    const expanded: string[] = []\n    events.forEach((event) => {\n      if (event === \"hover\") {\n        expanded.push(\"mouseenter\", \"mouseleave\")\n      } else {\n        expanded.push(event)\n      }\n    })\n    return expanded\n  }\n\n  /**\n   * Find matching closing parenthesis, respecting quotes\n   * Returns index of closing paren, or -1 if unbalanced\n   */\n  function findClosingParen(str: string, startIndex: number): number {\n    let depth = 1\n    let inQuotes = false\n    let quote: string | null = null\n\n    for (let i = startIndex; i < str.length; i++) {\n      const c = str[i]\n      const isQ = c === '\"' || c === \"'\"\n\n      if (isQ && !inQuotes) {\n        inQuotes = true\n        quote = c\n        continue\n      }\n      if (isQ && inQuotes && c === quote) {\n        inQuotes = false\n        quote = null\n        continue\n      }\n\n      if (!inQuotes) {\n        if (c === \"(\") depth++\n        else if (c === \")\") {\n          depth--\n          if (depth === 0) {\n            return i\n          }\n        }\n      }\n    }\n\n    return -1 // unbalanced\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Parsers\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Split a string on delimiters, ignoring content inside () and quotes\n   */\n  function getParts(str: string, delims: string[]) {\n    const out: string[] = []\n    let curr = \"\"\n    let depth = 0\n    let inQuotes = false\n    let quote: string | null = null\n    const delimiterSet = new Set(delims)\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i]\n      const isQ = c === '\"' || c === \"'\"\n\n      if (isQ && !inQuotes) {\n        inQuotes = true\n        quote = c\n        curr += c\n        continue\n      }\n      if (isQ && inQuotes && c === quote) {\n        inQuotes = false\n        quote = null\n        curr += c\n        continue\n      }\n\n      if (!inQuotes) {\n        if (c === \"(\") depth++\n        else if (c === \")\" && depth > 0) depth--\n\n        if (depth === 0 && delimiterSet.has(c)) {\n          if (curr.trim()) out.push(curr.trim())\n          curr = \"\"\n          continue\n        }\n      }\n\n      curr += c\n    }\n\n    if (curr.trim()) out.push(curr.trim())\n    return out\n  }\n\n  function parseAttrBlock(block: string) {\n    const contents = block.slice(1, -1).trim()\n    const out: TAttrMap = {}\n    if (!contents) return out\n\n    const parts = getParts(contents, [\" \"])\n    parts.forEach((part) => {\n      if (!part.includes(\":\")) {\n        out[part] = null\n        return\n      }\n      const [k, v] = part.split(\":\")\n      out[k] = v\n    })\n\n    return out\n  }\n\n  function parseOptionsBlock(s: string) {\n    const contents = s.slice(1, -1).trim()\n    const opts: TActionOptions = {}\n    if (!contents) return opts\n\n    const parts = getParts(contents, [\" \"])\n    parts.forEach((part) => {\n      const [k, v] = part.split(\":\")\n      if (!k) return\n\n      if (k === \"delay\") {\n        const n = Number(v)\n        if (!Number.isNaN(n)) opts.delay = n\n        return\n      }\n\n      if (k === \"debounce\") {\n        const n = Number(v)\n        if (!Number.isNaN(n)) opts.debounce = n\n        return\n      }\n\n      opts[k] = v ?? true\n    })\n\n    return opts\n  }\n\n  function parseRunBlock(part: string): TRunAction | null {\n    if (!part.startsWith(\"run(\")) return null\n\n    const start = \"run(\".length\n    const closingIndex = findClosingParen(part, start)\n\n    if (closingIndex === -1) {\n      console.warn(\"Swiss: unbalanced parentheses in run()\", part)\n      return null\n    }\n\n    const js = part.slice(start, closingIndex)\n\n    let options: TActionOptions | undefined\n    const rest = part.slice(closingIndex + 1).trim()\n\n    if (rest) {\n      if (rest.startsWith(\"(\") && rest.endsWith(\")\")) {\n        options = parseOptionsBlock(rest)\n      } else {\n        console.warn(\"Swiss: invalid options block in run()\", part)\n      }\n    }\n\n    return { type: \"run\", js, options }\n  }\n\n  function parseEventBlock(part: string): TEventAction | null {\n    if (!part.startsWith(\"event(\")) return null\n    if (!part.endsWith(\")\") && !part.includes(\")(\")) {\n      console.warn(\"Swiss: invalid event() syntax:\", part)\n      return null\n    }\n\n    const start = \"event(\".length\n    const closingIndex = findClosingParen(part, start)\n\n    if (closingIndex === -1) {\n      console.warn(\"Swiss: unbalanced parentheses in event()\", part)\n      return null\n    }\n\n    const payload = part.slice(start, closingIndex).trim()\n    if (!payload) {\n      console.warn(\"Swiss: empty event() payload:\", part)\n      return null\n    }\n\n    const eventNames = getParts(payload, [\" \"])\n    let options: TActionOptions | undefined\n\n    const rest = part.slice(closingIndex + 1).trim()\n    if (rest) {\n      if (rest.startsWith(\"(\") && rest.endsWith(\")\")) {\n        options = parseOptionsBlock(rest)\n      } else {\n        console.warn(\"Swiss: invalid options block in event()\", part)\n      }\n    }\n\n    return { type: \"event\", eventNames, options }\n  }\n\n  /**\n   * Parse the data-swiss attribute into a list of actions\n   */\n  function parseDataSwissActionsAttr(raw: string): TParsedAction[] {\n    if (!raw) return []\n\n    return getParts(raw, [\" \", \";\"])\n      .map<TParsedAction | null>((block) => {\n        // 1) run(...)\n        if (block.startsWith(\"run(\")) {\n          return parseRunBlock(block)\n        }\n\n        // 2) event(...)\n        if (block.startsWith(\"event(\")) {\n          return parseEventBlock(block)\n        }\n\n        // 3) class/attr actions:\n        //    type[selector](payload)(options?) or type(payload)(options?)\n        //    If selector is omitted, defaults to \"this\"\n        const match = block.match(\n          /^(\\w+)(?:\\[(.+?)\\])?\\((.+?)\\)(?:\\((.+?)\\))?$/,\n        )\n        if (!match) {\n          console.warn(\"Swiss: invalid action format:\", block)\n          return null\n        }\n\n        const [, rawType, selRaw, payloadRaw, optsRaw] = match\n        if (!isClassOrAttrActionType(rawType)) {\n          console.warn(\"Swiss: unsupported action type:\", rawType)\n          return null\n        }\n\n        const selector = selRaw ? selRaw.trim() : \"this\"\n        const payload = payloadRaw.trim()\n\n        const classNames: string[] = []\n        let attrs: TAttrMap = {}\n        const parts = getParts(payload, [\" \"])\n\n        parts.forEach((t) => {\n          if (t.startsWith(\"{\") && t.endsWith(\"}\")) {\n            attrs = { ...attrs, ...parseAttrBlock(t) }\n          } else {\n            classNames.push(t)\n          }\n        })\n\n        const options = optsRaw ? parseOptionsBlock(`(${optsRaw})`) : undefined\n\n        const hasClassAction = classNames.length > 0\n        const hasAttrAction = Object.keys(attrs).length > 0\n        const hasComboAction = hasClassAction && hasAttrAction\n\n        if (hasComboAction) {\n          return {\n            type: rawType,\n            selector,\n            classNames,\n            attrs,\n            options,\n          } as TComboAction\n        }\n        if (hasAttrAction) {\n          return {\n            type: rawType,\n            selector,\n            attrs,\n            options,\n          } as TAttrAction\n        }\n        return {\n          type: rawType,\n          selector,\n          classNames,\n          options,\n        } as TClassAction\n      })\n      .filter((x): x is TParsedAction => Boolean(x))\n  }\n\n  /**\n   * Parse all data-swiss attributes from an element\n   */\n  function parseElementAttributes(elHtml: HTMLElement) {\n    const raw = elHtml.getAttribute(\"data-swiss\") || \"\"\n    const actions = parseDataSwissActionsAttr(raw)\n    const hasActions = actions.length > 0\n\n    const eventsRaw =\n      hasActions && elHtml.hasAttribute(\"data-swiss-on\")\n        ? elHtml.getAttribute(\"data-swiss-on\")!.split(/\\s+/).filter(Boolean)\n        : hasActions\n          ? [\"click\"]\n          : []\n    const events = expandEventShorthands(eventsRaw)\n\n    return {\n      raw,\n      actions,\n      hasActions,\n      events,\n      stopProp: elHtml.hasAttribute(\"data-swiss-stop-propagation\"),\n      ifElSelector: elHtml.getAttribute(\"data-swiss-if\"),\n      whenMedia: elHtml.getAttribute(\"data-swiss-when\"),\n      resetOnResize: elHtml.hasAttribute(\"data-swiss-reset-on-resize\"),\n      resetWhenDisabled: elHtml.hasAttribute(\"data-swiss-reset-when-disabled\"),\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Selectors\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Resolve a selector to a list of elements\n   * Supports both global selectors (e.g., \"#id\", \".class\") and relative selectors (e.g., \">div\", \"+.sibling\")\n   */\n  function resolveTargets(el: Element, sel: string): Element[] {\n    // console.log(\"Swiss: resolving selector:\", sel)\n    if (sel === \"this\") return [el]\n    try {\n      // Relative selectors: start with >, +, or ~\n\n      if (sel.startsWith(\">\")) {\n        // Use :scope prefix to make querySelector relative to the current element\n        return Array.from(el.querySelectorAll(`:scope${sel}`))\n      }\n\n      if (sel.startsWith(\"+\")) {\n        const sibling = el.nextElementSibling\n        if (!sibling) return []\n        return sibling.matches(sel.slice(1)) ? [sibling] : []\n      }\n\n      if (sel.startsWith(\"~\")) {\n        const out: Element[] = []\n        let sib = el.nextElementSibling\n        const matchSel = sel.slice(1)\n\n        while (sib) {\n          if (sib.matches(matchSel)) out.push(sib)\n          sib = sib.nextElementSibling\n        }\n        return out\n      }\n\n      // Global selectors (IDs, classes, complex selectors)\n      return Array.from(document.querySelectorAll(sel))\n    } catch {\n      console.warn(\"Swiss: bad selector:\", sel)\n      return []\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | State Tracking\n  |--------------------------------------------------------------------------\n  */\n\n  function getElementInitialState(\n    el: Element,\n    actions: TParsedAction[],\n  ): TInitialState {\n    const out: TInitialState = []\n\n    actions.forEach((a) => {\n      if (!(\"selector\" in a)) return // run/event have no selector\n\n      const els = resolveTargets(el, a.selector)\n\n      els.forEach((el) => {\n        if (hasAttrs(a)) {\n          for (const attr in a.attrs) {\n            const v = el.getAttribute(attr)\n            out.push({ el: el, attr, value: v })\n          }\n        }\n\n        if (hasClassNames(a)) {\n          for (const c of a.classNames) {\n            out.push({\n              el: el,\n              className: c,\n              hasClass: el.classList.contains(c),\n            })\n          }\n        }\n      })\n    })\n\n    return out\n  }\n\n  function restoreElementStateToInitial(initialState: TInitialState) {\n    initialState.forEach((item) => {\n      if (\"className\" in item) {\n        if (item.hasClass) item.el.classList.add(item.className)\n        else item.el.classList.remove(item.className)\n      } else {\n        if (item.value === null) item.el.removeAttribute(item.attr)\n        else item.el.setAttribute(item.attr, item.value)\n      }\n    })\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Actions\n  |--------------------------------------------------------------------------\n  */\n\n  function applyClassAction(\n    target: Element,\n    actionType: TBaseClassOrAttrActionType,\n    classNames: string[],\n  ) {\n    classNames.forEach((cls) => {\n      if (actionType === \"toggle\") target.classList.toggle(cls)\n      else if (actionType === \"add\") target.classList.add(cls)\n      else target.classList.remove(cls)\n    })\n  }\n\n  function applyAttrAction(\n    target: Element,\n    actionType: TBaseClassOrAttrActionType,\n    attrs: TAttrMap,\n  ) {\n    for (const attr in attrs) {\n      const raw = attrs[attr]\n\n      if (actionType === \"remove\") {\n        target.removeAttribute(attr)\n        continue\n      }\n\n      if (actionType === \"toggle\") {\n        if (raw && raw.includes(\"|\")) {\n          const [l, r] = raw.split(\"|\")\n          const cur = target.getAttribute(attr)\n          target.setAttribute(attr, cur === l ? r : l)\n          continue\n        }\n\n        if (raw === null) {\n          if (target.hasAttribute(attr)) target.removeAttribute(attr)\n          else target.setAttribute(attr, \"\")\n          continue\n        }\n\n        if (target.getAttribute(attr) === raw) target.removeAttribute(attr)\n        else target.setAttribute(attr, raw)\n        continue\n      }\n\n      if (actionType === \"add\") {\n        if (raw === null) target.setAttribute(attr, \"\")\n        else target.setAttribute(attr, raw)\n      }\n    }\n  }\n\n  function runActionImmediate(el: Element, action: TParsedAction) {\n    switch (action.type) {\n      case \"toggle\":\n      case \"add\":\n      case \"remove\": {\n        const els = resolveTargets(el, action.selector)\n\n        els.forEach((el) => {\n          if (hasClassNames(action)) {\n            applyClassAction(el, action.type, action.classNames)\n          }\n          if (hasAttrs(action)) {\n            applyAttrAction(el, action.type, action.attrs)\n          }\n        })\n        return\n      }\n\n      case \"run\":\n        try {\n          new Function(action.js)()\n        } catch (err) {\n          console.error(\"Swiss run error:\", err)\n        }\n        return\n\n      case \"event\":\n        action.eventNames.forEach((name) => {\n          el.dispatchEvent(new CustomEvent(name, { bubbles: true }))\n        })\n        return\n    }\n  }\n\n  function runActionWithDelay(\n    action: TParsedAction,\n    exec: (a: TParsedAction) => void,\n  ) {\n    const delay = action.options?.delay\n    if (delay && delay > 0) {\n      setTimeout(() => exec(action), delay)\n    } else {\n      exec(action)\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Enter/Exit Observer\n  |--------------------------------------------------------------------------\n  */\n\n  const enterExitMap = new WeakMap<\n    Element,\n    { entered: boolean; timers: Map<TParsedAction, number> }\n  >()\n\n  function executeActionsWithTiming(\n    el: Element,\n    actions: TParsedAction[],\n    rec: { entered: boolean; timers: Map<TParsedAction, number> },\n  ) {\n    actions.forEach((a) => {\n      const debounceEnabled =\n        a.options?.debounce !== undefined ? a.options.debounce > 0 : true // default ON for enter/exit\n\n      const delayMs = typeof a.options?.delay === \"number\" ? a.options.delay : 0\n      const debounceMs =\n        typeof a.options?.debounce === \"number\"\n          ? a.options.debounce\n          : DEFAULT_DEBOUNCE_MS\n\n      const executeAction = () => {\n        if (delayMs > 0) setTimeout(() => runActionImmediate(el, a), delayMs)\n        else runActionImmediate(el, a)\n      }\n\n      if (debounceEnabled) {\n        const existing = rec.timers.get(a)\n        if (existing) clearTimeout(existing)\n\n        const id = window.setTimeout(executeAction, debounceMs)\n        rec.timers.set(a, id)\n      } else {\n        executeAction()\n      }\n    })\n  }\n\n  function handleEnterExit(\n    el: Element,\n    events: string[],\n    actions: TParsedAction[],\n    entry: IntersectionObserverEntry,\n  ) {\n    if (!events.includes(\"enter\") && !events.includes(\"exit\")) return\n\n    let rec = enterExitMap.get(el)\n    if (!rec) {\n      rec = { entered: false, timers: new Map() }\n      enterExitMap.set(el, rec)\n    }\n\n    const isVisible = entry.isIntersecting\n\n    // ENTER: fire only when we transition into visible at least once\n    if (isVisible) {\n      if (rec.entered) return\n\n      rec.entered = true\n\n      if (events.includes(\"enter\")) {\n        executeActionsWithTiming(el, actions, rec)\n      }\n    }\n\n    // EXIT: fire only on visible â†’ not visible transitions\n    if (!isVisible && rec.entered) {\n      rec.entered = false\n\n      if (events.includes(\"exit\")) {\n        executeActionsWithTiming(el, actions, rec)\n      }\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Init Element\n  |--------------------------------------------------------------------------\n  */\n\n  function initElement(el: Element) {\n    const elHtml = el as HTMLElement\n\n    const {\n      actions,\n      hasActions,\n      events,\n      stopProp,\n      ifElSelector,\n      whenMedia,\n      resetOnResize,\n      resetWhenDisabled,\n    } = parseElementAttributes(elHtml)\n\n    let initialState: TInitialState | null = null\n    let active = false\n\n    function conditionActive() {\n      if (!ifElSelector) return true\n      const m = document.querySelector(ifElSelector)\n      return !!(m && m.matches(ifElSelector))\n    }\n\n    function actionHandler() {\n      if (!conditionActive()) return\n      actions.forEach((a) =>\n        runActionWithDelay(a, (act) => runActionImmediate(elHtml, act)),\n      )\n    }\n\n    function outsideListener(e: MouseEvent | TouchEvent) {\n      if (!conditionActive()) return\n\n      const target = e.target as Element | null\n      if (!target) return\n\n      // inside the element itself\n      if (elHtml.contains(target)) return\n\n      // explicit ignore selector\n      const ignore = elHtml.getAttribute(\"data-swiss-on-click-outside-ignore\")\n\n      if (ignore) {\n        // Support multiple selectors separated by commas\n        // e.g., \".menu-item, .some-other-class\" or \".menu-item .some-other-class\"\n        const shouldIgnoreElements = Array.from(\n          document.querySelectorAll(ignore),\n        )\n\n        const shouldIgnore = shouldIgnoreElements.some((el) =>\n          el.contains(target),\n        )\n\n        if (shouldIgnore) return\n      }\n\n      actionHandler()\n    }\n\n    function enable() {\n      if (active) return\n      active = true\n\n      if (stopProp) {\n        elHtml.addEventListener(\"click\", (e) => {\n          if (e.target === elHtml) e.stopPropagation()\n        })\n      }\n\n      if (hasActions) {\n        initialState = getElementInitialState(elHtml, actions)\n\n        events.forEach((ev) => {\n          if (ev === \"clickOutside\") {\n            document.addEventListener(\"mousedown\", outsideListener)\n            document.addEventListener(\"touchstart\", outsideListener)\n          } else if ([\"enter\", \"exit\"].includes(ev)) {\n            // handled via IntersectionObserver\n          } else {\n            elHtml.addEventListener(ev, actionHandler)\n          }\n        })\n      }\n    }\n\n    function disable() {\n      if (!active) return\n      active = false\n\n      if (hasActions) {\n        events.forEach((ev) => {\n          if (ev === \"clickOutside\") {\n            document.removeEventListener(\"mousedown\", outsideListener)\n            document.removeEventListener(\"touchstart\", outsideListener)\n          } else if ([\"enter\", \"exit\"].includes(ev)) {\n            // observer cleanup is handled via GC\n          } else {\n            elHtml.removeEventListener(ev, actionHandler)\n          }\n        })\n\n        if (resetWhenDisabled && initialState)\n          restoreElementStateToInitial(initialState)\n      }\n    }\n\n    function evaluate() {\n      if (!whenMedia || window.matchMedia(whenMedia).matches) enable()\n      else disable()\n    }\n\n    // ENTER/EXIT observer setup\n    if (events.includes(\"enter\") || events.includes(\"exit\")) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.target === elHtml) {\n              handleEnterExit(elHtml, events, actions, entry)\n            }\n          })\n        },\n        { threshold: DEFAULT_INTERSECTION_THRESHOLD },\n      )\n\n      observer.observe(elHtml)\n    }\n\n    // BOOT\n    if (hasActions || stopProp) {\n      evaluate()\n\n      // media-query driven enable/disable\n      if (whenMedia) {\n        window.addEventListener(\"resize\", evaluate)\n      }\n\n      // reset-on-resize always restores initial on ANY resize\n      if (resetOnResize) {\n        window.addEventListener(\"resize\", () => {\n          if (initialState) restoreElementStateToInitial(initialState)\n        })\n      }\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Init All\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Init all elements with data-swiss attributes\n   */\n  function initAll() {\n    document\n      .querySelectorAll(\n        \"[data-swiss], [data-swiss-stop-propagation], [data-swiss-on='clickOutside']\",\n      )\n      .forEach(initElement)\n  }\n\n  if (document.readyState !== \"loading\") initAll()\n  else document.addEventListener(\"DOMContentLoaded\", initAll)\n})()\n"],"names":["hasClassNames","action","hasAttrs","findClosingParen","str","startIndex","depth","inQuotes","quote","i","length","c","isQ","getParts","delims","out","curr","delimiterSet","Set","has","trim","push","parseOptionsBlock","s","contents","slice","opts","forEach","part","_part$split2","split","k","v","n","Number","isNaN","debounce","delay","resolveTargets","el","sel","startsWith","Array","from","querySelectorAll","sibling","nextElementSibling","matches","sib","matchSel","document","_unused","console","warn","restoreElementStateToInitial","initialState","item","hasClass","classList","add","className","remove","value","removeAttribute","attr","setAttribute","runActionImmediate","type","selector","target","actionType","classNames","cls","toggle","attrs","raw","includes","_raw$split","l","r","cur","getAttribute","hasAttribute","applyAttrAction","Function","js","err","error","eventNames","name","dispatchEvent","CustomEvent","bubbles","enterExitMap","WeakMap","executeActionsWithTiming","actions","rec","a","_a$options","_a$options2","_a$options3","debounceEnabled","undefined","options","delayMs","debounceMs","executeAction","setTimeout","existing","timers","get","clearTimeout","id","window","set","initElement","elHtml","_parseElementAttribut","map","block","closingIndex","rest","endsWith","parseRunBlock","payload","parseEventBlock","match","rawType","selRaw","payloadRaw","optsRaw","t","_extends","_part$split","parseAttrBlock","hasClassAction","hasAttrAction","Object","keys","filter","x","Boolean","parseDataSwissActionsAttr","hasActions","events","expanded","event","expandEventShorthands","stopProp","ifElSelector","whenMedia","resetOnResize","resetWhenDisabled","parseElementAttributes","active","conditionActive","m","querySelector","actionHandler","exec","act","_action$options","outsideListener","e","contains","ignore","shouldIgnore","some","evaluate","matchMedia","addEventListener","stopPropagation","_step","_iterator","_createForOfIteratorHelperLoose","done","getElementInitialState","ev","removeEventListener","observer","IntersectionObserver","entries","entry","entered","Map","isVisible","isIntersecting","handleEnterExit","threshold","observe","initAll","readyState"],"mappings":"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"}