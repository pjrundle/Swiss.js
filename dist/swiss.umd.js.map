{"version":3,"file":"swiss.umd.js","sources":["../src/swiss.ts"],"sourcesContent":["(function () {\n  /*\n  |--------------------------------------------------------------------------\n  | Types\n  |--------------------------------------------------------------------------\n  */\n\n  type TBaseClassOrAttrActionType = \"toggle\" | \"add\" | \"remove\";\n\n  type TActionOptions = {\n    delay?: number;\n    debounce?: number;\n    [key: string]: unknown;\n  };\n\n  type TAttrMap = {\n    [key: string]: string | null;\n  };\n\n  type TRunAction = {\n    type: \"run\";\n    js: string;\n    options?: TActionOptions;\n  };\n\n  type TEventAction = {\n    type: \"event\";\n    eventNames: string[]; // supports event(foo bar baz)\n    options?: TActionOptions;\n  };\n\n  type TParsedAction =\n    | TClassAction\n    | TAttrAction\n    | TComboAction\n    | TRunAction\n    | TEventAction;\n\n  type TInitialClassState = {\n    el: Element;\n    className: string;\n    hasClass: boolean;\n  };\n\n  type TInitialAttrState = {\n    el: Element;\n    attr: string;\n    value: string | null;\n  };\n\n  type TInitialState = (TInitialClassState | TInitialAttrState)[];\n\n  interface TBaseClassOrAttrAction {\n    type: TBaseClassOrAttrActionType;\n    selector: string;\n    options?: TActionOptions;\n  }\n\n  interface TClassAction extends TBaseClassOrAttrAction {\n    classNames: string[];\n    attrs?: undefined;\n  }\n\n  interface TAttrAction extends TBaseClassOrAttrAction {\n    attrs: TAttrMap;\n    classNames?: undefined;\n  }\n\n  interface TComboAction extends TBaseClassOrAttrAction {\n    classNames: string[];\n    attrs: TAttrMap;\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Constants\n  |--------------------------------------------------------------------------\n  */\n\n  const DEFAULT_DEBOUNCE_MS = 100;\n  const DEFAULT_INTERSECTION_THRESHOLD = 0;\n\n  /*\n  |--------------------------------------------------------------------------\n  | Utils\n  |--------------------------------------------------------------------------\n  */\n\n  function isClassOrAttrActionType(\n    actionType: string,\n  ): actionType is TBaseClassOrAttrActionType {\n    return [\"toggle\", \"add\", \"remove\"].includes(actionType);\n  }\n\n  function hasClassNames(\n    action: TParsedAction,\n  ): action is TClassAction | TComboAction {\n    return \"classNames\" in action;\n  }\n\n  function hasAttrs(\n    action: TParsedAction,\n  ): action is TAttrAction | TComboAction {\n    return \"attrs\" in action;\n  }\n\n  /**\n   * Expand event shorthands (e.g., \"hover\" -> \"mouseenter mouseleave\")\n   */\n  function expandEventShorthands(events: string[]): string[] {\n    const expanded: string[] = [];\n    events.forEach((event) => {\n      if (event === \"hover\") {\n        expanded.push(\"mouseenter\", \"mouseleave\");\n      } else {\n        expanded.push(event);\n      }\n    });\n    return expanded;\n  }\n\n  /**\n   * Find matching closing parenthesis, respecting quotes\n   * Returns index of closing paren, or -1 if unbalanced\n   */\n  function findClosingParen(str: string, startIndex: number): number {\n    let depth = 1;\n    let inQuotes = false;\n    let quote: string | null = null;\n\n    for (let i = startIndex; i < str.length; i++) {\n      const c = str[i];\n      const isQ = c === '\"' || c === \"'\";\n\n      if (isQ && !inQuotes) {\n        inQuotes = true;\n        quote = c;\n        continue;\n      }\n      if (isQ && inQuotes && c === quote) {\n        inQuotes = false;\n        quote = null;\n        continue;\n      }\n\n      if (!inQuotes) {\n        if (c === \"(\") depth++;\n        else if (c === \")\") {\n          depth--;\n          if (depth === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1; // unbalanced\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Parsers\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Split a string on delimiters, ignoring content inside () and quotes\n   */\n  function getParts(str: string, delims: string[]) {\n    const out: string[] = [];\n    let curr = \"\";\n    let depth = 0;\n    let inQuotes = false;\n    let quote: string | null = null;\n    const delimiterSet = new Set(delims);\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      const isQ = c === '\"' || c === \"'\";\n\n      if (isQ && !inQuotes) {\n        inQuotes = true;\n        quote = c;\n        curr += c;\n        continue;\n      }\n      if (isQ && inQuotes && c === quote) {\n        inQuotes = false;\n        quote = null;\n        curr += c;\n        continue;\n      }\n\n      if (!inQuotes) {\n        if (c === \"(\") depth++;\n        else if (c === \")\" && depth > 0) depth--;\n\n        if (depth === 0 && delimiterSet.has(c)) {\n          if (curr.trim()) out.push(curr.trim());\n          curr = \"\";\n          continue;\n        }\n      }\n\n      curr += c;\n    }\n\n    if (curr.trim()) out.push(curr.trim());\n    return out;\n  }\n\n  function parseAttrBlock(block: string) {\n    const contents = block.slice(1, -1).trim();\n    const out: TAttrMap = {};\n    if (!contents) return out;\n\n    const parts = getParts(contents, [\" \"]);\n    parts.forEach((part) => {\n      if (!part.includes(\":\")) {\n        out[part] = null;\n        return;\n      }\n      const [k, v] = part.split(\":\");\n      out[k] = v;\n    });\n\n    return out;\n  }\n\n  function parseOptionsBlock(s: string) {\n    const contents = s.slice(1, -1).trim();\n    const opts: TActionOptions = {};\n    if (!contents) return opts;\n\n    const parts = getParts(contents, [\" \"]);\n    parts.forEach((part) => {\n      const [k, v] = part.split(\":\");\n      if (!k) return;\n\n      if (k === \"delay\") {\n        const n = Number(v);\n        if (!Number.isNaN(n)) opts.delay = n;\n        return;\n      }\n\n      if (k === \"debounce\") {\n        const n = Number(v);\n        if (!Number.isNaN(n)) opts.debounce = n;\n        return;\n      }\n\n      opts[k] = v ?? true;\n    });\n\n    return opts;\n  }\n\n  function parseRunBlock(part: string): TRunAction | null {\n    if (!part.startsWith(\"run(\")) return null;\n\n    const start = \"run(\".length;\n    const closingIndex = findClosingParen(part, start);\n\n    if (closingIndex === -1) {\n      console.warn(\"Swiss: unbalanced parentheses in run()\", part);\n      return null;\n    }\n\n    const js = part.slice(start, closingIndex);\n\n    let options: TActionOptions | undefined;\n    const rest = part.slice(closingIndex + 1).trim();\n\n    if (rest) {\n      if (rest.startsWith(\"(\") && rest.endsWith(\")\")) {\n        options = parseOptionsBlock(rest);\n      } else {\n        console.warn(\"Swiss: invalid options block in run()\", part);\n      }\n    }\n\n    return { type: \"run\", js, options };\n  }\n\n  function parseEventBlock(part: string): TEventAction | null {\n    if (!part.startsWith(\"event(\")) return null;\n    if (!part.endsWith(\")\") && !part.includes(\")(\")) {\n      console.warn(\"Swiss: invalid event() syntax:\", part);\n      return null;\n    }\n\n    const start = \"event(\".length;\n    const closingIndex = findClosingParen(part, start);\n\n    if (closingIndex === -1) {\n      console.warn(\"Swiss: unbalanced parentheses in event()\", part);\n      return null;\n    }\n\n    const payload = part.slice(start, closingIndex).trim();\n    if (!payload) {\n      console.warn(\"Swiss: empty event() payload:\", part);\n      return null;\n    }\n\n    const eventNames = getParts(payload, [\" \"]);\n    let options: TActionOptions | undefined;\n\n    const rest = part.slice(closingIndex + 1).trim();\n    if (rest) {\n      if (rest.startsWith(\"(\") && rest.endsWith(\")\")) {\n        options = parseOptionsBlock(rest);\n      } else {\n        console.warn(\"Swiss: invalid options block in event()\", part);\n      }\n    }\n\n    return { type: \"event\", eventNames, options };\n  }\n\n  /**\n   * Parse the data-swiss attribute into a list of actions\n   */\n  function parseDataSwissActionsAttr(raw: string): TParsedAction[] {\n    if (!raw) return [];\n\n    return getParts(raw, [\" \", \";\"])\n      .map<TParsedAction | null>((block) => {\n        // 1) run(...)\n        if (block.startsWith(\"run(\")) {\n          return parseRunBlock(block);\n        }\n\n        // 2) event(...)\n        if (block.startsWith(\"event(\")) {\n          return parseEventBlock(block);\n        }\n\n        // 3) class/attr actions:\n        //    type[selector](payload)(options?) or type(payload)(options?)\n        //    If selector is omitted, defaults to \"this\"\n        const match = block.match(\n          /^(\\w+)(?:\\[(.+?)\\])?\\((.+?)\\)(?:\\((.+?)\\))?$/,\n        );\n        if (!match) {\n          console.warn(\"Swiss: invalid action format:\", block);\n          return null;\n        }\n\n        const [, rawType, selRaw, payloadRaw, optsRaw] = match;\n        if (!isClassOrAttrActionType(rawType)) {\n          console.warn(\"Swiss: unsupported action type:\", rawType);\n          return null;\n        }\n\n        const selector = selRaw ? selRaw.trim() : \"this\";\n        const payload = payloadRaw.trim();\n\n        const classNames: string[] = [];\n        let attrs: TAttrMap = {};\n        const parts = getParts(payload, [\" \"]);\n\n        parts.forEach((t) => {\n          if (t.startsWith(\"{\") && t.endsWith(\"}\")) {\n            attrs = { ...attrs, ...parseAttrBlock(t) };\n          } else {\n            classNames.push(t);\n          }\n        });\n\n        const options = optsRaw ? parseOptionsBlock(`(${optsRaw})`) : undefined;\n\n        const hasClassAction = classNames.length > 0;\n        const hasAttrAction = Object.keys(attrs).length > 0;\n        const hasComboAction = hasClassAction && hasAttrAction;\n\n        if (hasComboAction) {\n          return {\n            type: rawType,\n            selector,\n            classNames,\n            attrs,\n            options,\n          } as TComboAction;\n        }\n        if (hasAttrAction) {\n          return {\n            type: rawType,\n            selector,\n            attrs,\n            options,\n          } as TAttrAction;\n        }\n        return {\n          type: rawType,\n          selector,\n          classNames,\n          options,\n        } as TClassAction;\n      })\n      .filter((x): x is TParsedAction => Boolean(x));\n  }\n\n  /**\n   * Parse all data-swiss attributes from an element\n   */\n  function parseElementAttributes(elHtml: HTMLElement) {\n    const raw = elHtml.getAttribute(\"data-swiss\") || \"\";\n    const actions = parseDataSwissActionsAttr(raw);\n    const hasActions = actions.length > 0;\n\n    const eventsRaw =\n      hasActions && elHtml.hasAttribute(\"data-swiss-on\")\n        ? elHtml.getAttribute(\"data-swiss-on\")!.split(/\\s+/).filter(Boolean)\n        : hasActions\n          ? [\"click\"]\n          : [];\n    const events = expandEventShorthands(eventsRaw);\n\n    return {\n      raw,\n      actions,\n      hasActions,\n      events,\n      stopProp: elHtml.hasAttribute(\"data-swiss-stop-propagation\"),\n      ifElSelector: elHtml.getAttribute(\"data-swiss-if\"),\n      whenMedia: elHtml.getAttribute(\"data-swiss-when\"),\n      resetOnResize: elHtml.hasAttribute(\"data-swiss-reset-on-resize\"),\n      resetWhenDisabled: elHtml.hasAttribute(\"data-swiss-reset-when-disabled\"),\n    };\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Selectors\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Resolve a selector to a list of elements\n   * Supports both global selectors (e.g., \"#id\", \".class\") and relative selectors (e.g., \">div\", \"+.sibling\")\n   */\n  function resolveTargets(el: Element, sel: string): Element[] {\n    if (sel === \"this\") return [el];\n    try {\n      // Relative selectors: start with >, +, or ~\n      // Use :scope prefix to make querySelector relative to the current element\n      if (sel.startsWith(\">\") || sel.startsWith(\"+\") || sel.startsWith(\"~\")) {\n        return Array.from(el.querySelectorAll(`:scope ${sel}`));\n      }\n\n      // Global selectors (IDs, classes, complex selectors)\n      return Array.from(document.querySelectorAll(sel));\n    } catch {\n      console.warn(\"Swiss: bad selector:\", sel);\n      return [];\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | State Tracking\n  |--------------------------------------------------------------------------\n  */\n\n  function getElementInitialState(\n    el: Element,\n    actions: TParsedAction[],\n  ): TInitialState {\n    const out: TInitialState = [];\n\n    actions.forEach((a) => {\n      if (!(\"selector\" in a)) return; // run/event have no selector\n\n      const els = resolveTargets(el, a.selector);\n\n      els.forEach((el) => {\n        if (hasAttrs(a)) {\n          for (const attr in a.attrs) {\n            const v = el.getAttribute(attr);\n            out.push({ el: el, attr, value: v });\n          }\n        }\n\n        if (hasClassNames(a)) {\n          for (const c of a.classNames) {\n            out.push({\n              el: el,\n              className: c,\n              hasClass: el.classList.contains(c),\n            });\n          }\n        }\n      });\n    });\n\n    return out;\n  }\n\n  function restoreElementStateToInitial(initialState: TInitialState) {\n    initialState.forEach((item) => {\n      if (\"className\" in item) {\n        if (item.hasClass) item.el.classList.add(item.className);\n        else item.el.classList.remove(item.className);\n      } else {\n        if (item.value === null) item.el.removeAttribute(item.attr);\n        else item.el.setAttribute(item.attr, item.value);\n      }\n    });\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Actions\n  |--------------------------------------------------------------------------\n  */\n\n  function applyClassAction(\n    target: Element,\n    actionType: TBaseClassOrAttrActionType,\n    classNames: string[],\n  ) {\n    classNames.forEach((cls) => {\n      if (actionType === \"toggle\") target.classList.toggle(cls);\n      else if (actionType === \"add\") target.classList.add(cls);\n      else target.classList.remove(cls);\n    });\n  }\n\n  function applyAttrAction(\n    target: Element,\n    actionType: TBaseClassOrAttrActionType,\n    attrs: TAttrMap,\n  ) {\n    for (const attr in attrs) {\n      const raw = attrs[attr];\n\n      if (actionType === \"remove\") {\n        target.removeAttribute(attr);\n        continue;\n      }\n\n      if (actionType === \"toggle\") {\n        if (raw && raw.includes(\"|\")) {\n          const [l, r] = raw.split(\"|\");\n          const cur = target.getAttribute(attr);\n          target.setAttribute(attr, cur === l ? r : l);\n          continue;\n        }\n\n        if (raw === null) {\n          if (target.hasAttribute(attr)) target.removeAttribute(attr);\n          else target.setAttribute(attr, \"\");\n          continue;\n        }\n\n        if (target.getAttribute(attr) === raw) target.removeAttribute(attr);\n        else target.setAttribute(attr, raw);\n        continue;\n      }\n\n      if (actionType === \"add\") {\n        if (raw === null) target.setAttribute(attr, \"\");\n        else target.setAttribute(attr, raw);\n      }\n    }\n  }\n\n  function runActionImmediate(el: Element, action: TParsedAction) {\n    switch (action.type) {\n      case \"toggle\":\n      case \"add\":\n      case \"remove\": {\n        const els = resolveTargets(el, action.selector);\n\n        els.forEach((el) => {\n          if (hasClassNames(action)) {\n            applyClassAction(el, action.type, action.classNames);\n          }\n          if (hasAttrs(action)) {\n            applyAttrAction(el, action.type, action.attrs);\n          }\n        });\n        return;\n      }\n\n      case \"run\":\n        try {\n          new Function(action.js)();\n        } catch (err) {\n          console.error(\"Swiss run error:\", err);\n        }\n        return;\n\n      case \"event\":\n        action.eventNames.forEach((name) => {\n          el.dispatchEvent(new CustomEvent(name, { bubbles: true }));\n        });\n        return;\n    }\n  }\n\n  function runActionWithDelay(\n    action: TParsedAction,\n    exec: (a: TParsedAction) => void,\n  ) {\n    const delay = action.options?.delay;\n    if (delay && delay > 0) {\n      setTimeout(() => exec(action), delay);\n    } else {\n      exec(action);\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Enter/Exit Observer\n  |--------------------------------------------------------------------------\n  */\n\n  const enterExitMap = new WeakMap<\n    Element,\n    { entered: boolean; timers: Map<TParsedAction, number> }\n  >();\n\n  function executeActionsWithTiming(\n    el: Element,\n    actions: TParsedAction[],\n    rec: { entered: boolean; timers: Map<TParsedAction, number> },\n  ) {\n    actions.forEach((a) => {\n      const debounceEnabled =\n        a.options?.debounce !== undefined ? a.options.debounce > 0 : true; // default ON for enter/exit\n\n      const delayMs =\n        typeof a.options?.delay === \"number\" ? a.options.delay : 0;\n      const debounceMs =\n        typeof a.options?.debounce === \"number\"\n          ? a.options.debounce\n          : DEFAULT_DEBOUNCE_MS;\n\n      const executeAction = () => {\n        if (delayMs > 0) setTimeout(() => runActionImmediate(el, a), delayMs);\n        else runActionImmediate(el, a);\n      };\n\n      if (debounceEnabled) {\n        const existing = rec.timers.get(a);\n        if (existing) clearTimeout(existing);\n\n        const id = window.setTimeout(executeAction, debounceMs);\n        rec.timers.set(a, id);\n      } else {\n        executeAction();\n      }\n    });\n  }\n\n  function handleEnterExit(\n    el: Element,\n    events: string[],\n    actions: TParsedAction[],\n    entry: IntersectionObserverEntry,\n  ) {\n    if (!events.includes(\"enter\") && !events.includes(\"exit\")) return;\n\n    let rec = enterExitMap.get(el);\n    if (!rec) {\n      rec = { entered: false, timers: new Map() };\n      enterExitMap.set(el, rec);\n    }\n\n    const isVisible = entry.isIntersecting;\n\n    // ENTER: fire only when we transition into visible at least once\n    if (isVisible) {\n      if (rec.entered) return;\n\n      rec.entered = true;\n\n      if (events.includes(\"enter\")) {\n        executeActionsWithTiming(el, actions, rec);\n      }\n    }\n\n    // EXIT: fire only on visible â†’ not visible transitions\n    if (!isVisible && rec.entered) {\n      rec.entered = false;\n\n      if (events.includes(\"exit\")) {\n        executeActionsWithTiming(el, actions, rec);\n      }\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Init Element\n  |--------------------------------------------------------------------------\n  */\n\n  function initElement(el: Element) {\n    const elHtml = el as HTMLElement;\n\n    const {\n      actions,\n      hasActions,\n      events,\n      stopProp,\n      ifElSelector,\n      whenMedia,\n      resetOnResize,\n      resetWhenDisabled,\n    } = parseElementAttributes(elHtml);\n\n    let initialState: TInitialState | null = null;\n    let active = false;\n\n    function conditionActive() {\n      if (!ifElSelector) return true;\n      const m = document.querySelector(ifElSelector);\n      return !!(m && m.matches(ifElSelector));\n    }\n\n    function actionHandler() {\n      if (!conditionActive()) return;\n      actions.forEach((a) =>\n        runActionWithDelay(a, (act) => runActionImmediate(elHtml, act)),\n      );\n    }\n\n    function outsideListener(e: MouseEvent | TouchEvent) {\n      if (!conditionActive()) return;\n      const target = e.target as Element | null;\n      if (!target) return;\n      if (elHtml.contains(target)) return;\n      if (target.closest(\"[data-swiss]\")) return;\n      actionHandler();\n    }\n\n    function enable() {\n      if (active) return;\n      active = true;\n\n      if (stopProp) {\n        elHtml.addEventListener(\"click\", (e) => {\n          if (e.target === elHtml) e.stopPropagation();\n        });\n      }\n\n      if (hasActions) {\n        initialState = getElementInitialState(elHtml, actions);\n\n        events.forEach((ev) => {\n          if (ev === \"clickOutside\") {\n            document.addEventListener(\"mousedown\", outsideListener);\n            document.addEventListener(\"touchstart\", outsideListener);\n          } else if ([\"enter\", \"exit\"].includes(ev)) {\n            // handled via IntersectionObserver\n          } else {\n            elHtml.addEventListener(ev, actionHandler);\n          }\n        });\n      }\n    }\n\n    function disable() {\n      if (!active) return;\n      active = false;\n\n      if (hasActions) {\n        events.forEach((ev) => {\n          if (ev === \"clickOutside\") {\n            document.removeEventListener(\"mousedown\", outsideListener);\n            document.removeEventListener(\"touchstart\", outsideListener);\n          } else if ([\"enter\", \"exit\"].includes(ev)) {\n            // observer cleanup is handled via GC\n          } else {\n            elHtml.removeEventListener(ev, actionHandler);\n          }\n        });\n\n        if (resetWhenDisabled && initialState)\n          restoreElementStateToInitial(initialState);\n      }\n    }\n\n    function evaluate() {\n      if (!whenMedia || window.matchMedia(whenMedia).matches) enable();\n      else disable();\n    }\n\n    // ENTER/EXIT observer setup\n    if (events.includes(\"enter\") || events.includes(\"exit\")) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.target === elHtml) {\n              handleEnterExit(elHtml, events, actions, entry);\n            }\n          });\n        },\n        { threshold: DEFAULT_INTERSECTION_THRESHOLD },\n      );\n\n      observer.observe(elHtml);\n    }\n\n    // BOOT\n    if (hasActions || stopProp) {\n      evaluate();\n\n      // media-query driven enable/disable\n      if (whenMedia) {\n        window.addEventListener(\"resize\", evaluate);\n      }\n\n      // reset-on-resize always restores initial on ANY resize\n      if (resetOnResize) {\n        window.addEventListener(\"resize\", () => {\n          if (initialState) restoreElementStateToInitial(initialState);\n        });\n      }\n    }\n  }\n\n  /*\n  |--------------------------------------------------------------------------\n  | Init All\n  |--------------------------------------------------------------------------\n  */\n\n  /**\n   * Init all elements with data-swiss attributes\n   */\n  function initAll() {\n    document\n      .querySelectorAll(\n        \"[data-swiss], [data-swiss-stop-propagation], [data-swiss-on='clickOutside']\",\n      )\n      .forEach(initElement);\n  }\n\n  if (document.readyState !== \"loading\") initAll();\n  else document.addEventListener(\"DOMContentLoaded\", initAll);\n})();\n"],"names":["hasClassNames","action","hasAttrs","findClosingParen","str","startIndex","depth","inQuotes","quote","i","length","c","isQ","getParts","delims","out","curr","delimiterSet","Set","has","trim","push","parseOptionsBlock","s","contents","slice","opts","forEach","part","_part$split2","split","k","v","n","Number","isNaN","debounce","delay","resolveTargets","el","sel","startsWith","Array","from","querySelectorAll","document","_unused","console","warn","restoreElementStateToInitial","initialState","item","hasClass","classList","add","className","remove","value","removeAttribute","attr","setAttribute","runActionImmediate","type","selector","target","actionType","classNames","cls","toggle","attrs","raw","includes","_raw$split","l","r","cur","getAttribute","hasAttribute","applyAttrAction","Function","js","err","error","eventNames","name","dispatchEvent","CustomEvent","bubbles","enterExitMap","WeakMap","executeActionsWithTiming","actions","rec","a","_a$options","_a$options2","_a$options3","debounceEnabled","undefined","options","delayMs","debounceMs","executeAction","setTimeout","existing","timers","get","clearTimeout","id","window","set","initElement","elHtml","_parseElementAttribut","map","block","closingIndex","rest","endsWith","parseRunBlock","payload","parseEventBlock","match","rawType","selRaw","payloadRaw","optsRaw","t","_extends","_part$split","parseAttrBlock","hasClassAction","hasAttrAction","Object","keys","filter","x","Boolean","parseDataSwissActionsAttr","hasActions","events","expanded","event","expandEventShorthands","stopProp","ifElSelector","whenMedia","resetOnResize","resetWhenDisabled","parseElementAttributes","active","conditionActive","m","querySelector","matches","actionHandler","exec","act","_action$options","outsideListener","e","contains","closest","evaluate","matchMedia","addEventListener","stopPropagation","_step","_iterator","_createForOfIteratorHelperLoose","done","getElementInitialState","ev","removeEventListener","observer","IntersectionObserver","entries","entry","entered","Map","isVisible","isIntersecting","handleEnterExit","threshold","observe","initAll","readyState"],"mappings":"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"}